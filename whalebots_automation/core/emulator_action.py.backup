"""
Window controller module for WhaleBots automation platform.

This module provides a SOLID-designed window automation system with proper
error handling, logging, and security validation for UI operations.
"""

import re
import time
import ctypes
from abc import ABC, abstractmethod
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

try:
    import win32con
    import win32gui
    import win32api
    WIN32_AVAILABLE = True
except ImportError:
    WIN32_AVAILABLE = False

try:
    from ..config import UIConfiguration
    from ..exceptions import (
        WindowError, WindowNotFoundError, UICoordinateError,
        DependencyError, TimeoutError, SecurityError
    )
    from ..logger import get_logger, log_performance
except ImportError:
    # Fallback for running tests directly
    from config import UIConfiguration
    from exceptions import (
        WindowError, WindowNotFoundError, UICoordinateError,
        DependencyError, TimeoutError, SecurityError
    )
    from logger import get_logger, log_performance


@dataclass
class WindowInfo:
    """Container for window information."""
    hwnd: int
    title: str
    window_rect: Tuple[int, int, int, int]
    client_rect: Tuple[int, int, int, int]
    is_visible: bool = True
    is_minimized: bool = False


# ============ INTERFACES ============

class IWindowFinder(ABC):
    """Interface for window finding operations."""

    @abstractmethod
    def find(self, pattern: str) -> List[int]:
        """
        Find windows matching the given pattern.

        Args:
            pattern: Regular expression pattern to match window titles

        Returns:
            List of window handles (hwnd)
        """
        pass


class IClickHandler(ABC):
    """Interface for click operations."""

    @abstractmethod
    def click(self, hwnd: int, x: int, y: int) -> bool:
        """
        Perform a click at the specified coordinates.

        Args:
            hwnd: Window handle
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)

        Returns:
            True if click was successful, False otherwise
        """
        pass


class IScrollHandler(ABC):
    """Interface for scroll operations."""

    @abstractmethod
    def scroll(self, hwnd: int, x: int, y: int, up: int, down: int) -> bool:
        """
        Perform scrolling at the specified coordinates.

        Args:
            hwnd: Window handle
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)
            up: Number of scroll-up operations
            down: Number of scroll-down operations

        Returns:
            True if scroll was successful, False otherwise
        """
        pass


# ============ IMPLEMENTATIONS ============

class RegexWindowFinder(IWindowFinder):
    """Window finder using regex pattern matching."""

    def __init__(self, config: UIConfiguration):
        """
        Initialize regex window finder.

        Args:
            config: UI configuration
        """
        if not WIN32_AVAILABLE:
            raise DependencyError("win32gui modules")

        self.config = config
        self.logger = get_logger(f"{__name__}.RegexWindowFinder")

    @log_performance()
    def find(self, pattern: str) -> List[int]:
        """
        Find windows matching regex pattern.

        Args:
            pattern: Regular expression pattern

        Returns:
            List of matching window handles

        Raises:
            WindowError: If window search fails
        """
        try:
            results = []

            def callback(hwnd, _):
                """Callback function for EnumWindows."""
                try:
                    if win32gui.IsWindowVisible(hwnd):
                        title = win32gui.GetWindowText(hwnd)
                        if title and re.search(pattern, title, re.IGNORECASE):
                            results.append(hwnd)
                            self.logger.debug(f"Found window: {title} (hwnd: {hex(hwnd)})")
                except Exception as e:
                    self.logger.warning(f"Error checking window {hwnd}: {e}")

            win32gui.EnumWindows(callback, None)

            self.logger.info(f"Found {len(results)} windows matching pattern: {pattern}")
            return results

        except Exception as e:
            raise WindowError(f"Failed to search for windows: {e}")


class HybridClickHandler(IClickHandler):
    """
    Click handler that tries message-based clicking first,
    then falls back to mouse-based clicking.
    """

    def __init__(self, config: UIConfiguration, security_config=None):
        """
        Initialize hybrid click handler.

        Args:
            config: UI configuration
            security_config: Security configuration (optional)
        """
        if not WIN32_AVAILABLE:
            raise DependencyError("win32api modules")

        self.config = config
        self.security_config = security_config
        self.logger = get_logger(f"{__name__}.HybridClickHandler")

    def _validate_coordinates(self, x: int, y: int) -> None:
        """
        Validate click coordinates for security.

        Args:
            x: X coordinate
            y: Y coordinate

        Raises:
            UICoordinateError: If coordinates are invalid
        """
        # Use security config if available, otherwise skip validation
        if (self.security_config and
            hasattr(self.security_config, 'validate_coordinates') and
            self.security_config.validate_coordinates):

            if not (self.security_config.min_coordinate_value <= x <= self.security_config.max_coordinate_value):
                raise UICoordinateError(
                    f"X coordinate out of bounds: {x}",
                    x=x, y=y
                )
            if not (self.security_config.min_coordinate_value <= y <= self.security_config.max_coordinate_value):
                raise UICoordinateError(
                    f"Y coordinate out of bounds: {y}",
                    x=x, y=y
                )

    @log_performance()
    def click(self, hwnd: int, x: int, y: int) -> bool:
        """
        Perform click using hybrid approach.

        Args:
            hwnd: Window handle
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)

        Returns:
            True if click was successful, False otherwise

        Raises:
            UICoordinateError: If coordinates are invalid
            WindowError: If click operation fails
        """
        self._validate_coordinates(x, y)

        self.logger.debug(f"Attempting click at ({x}, {y}) on window {hex(hwnd)}")

        # Try message-based click first (more reliable and less intrusive)
        if self._try_message_click(hwnd, x, y):
            self.logger.debug(f"Message-based click successful at ({x}, {y})")
            return True

        # Fall back to mouse-based click
        if self._try_mouse_click(hwnd, x, y):
            self.logger.debug(f"Mouse-based click successful at ({x}, {y})")
            return True

        raise WindowError(f"All click methods failed for window {hex(hwnd)} at ({x}, {y})")

    def _try_message_click(self, hwnd: int, x: int, y: int) -> bool:
        """
        Try message-based clicking.

        Args:
            hwnd: Window handle
            x: X coordinate
            y: Y coordinate

        Returns:
            True if successful, False otherwise
        """
        try:
            # Create lParam with coordinates
            lparam = win32api.MAKELONG(x, y)

            # Send mouse down and up messages
            win32api.PostMessage(hwnd, win32con.WM_LBUTTONDOWN, win32con.MK_LBUTTON, lparam)
            time.sleep(self.config.click_delay)
            win32api.PostMessage(hwnd, win32con.WM_LBUTTONUP, 0, lparam)

            return True

        except Exception as e:
            self.logger.debug(f"Message-based click failed: {e}")
            return False

    def _try_mouse_click(self, hwnd: int, x: int, y: int) -> bool:
        """
        Try mouse-based clicking.

        Args:
            hwnd: Window handle
            x: X coordinate
            y: Y coordinate

        Returns:
            True if successful, False otherwise
        """
        try:
            # Bring window to front
            self._bring_to_front(hwnd)

            # Convert client coordinates to screen coordinates
            sx, sy = win32gui.ClientToScreen(hwnd, (x, y))

            # Set cursor position
            win32api.SetCursorPos((sx, sy))
            time.sleep(self.config.click_delay)

            # Perform click
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
            time.sleep(self.config.click_delay)
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)

            return True

        except Exception as e:
            self.logger.debug(f"Mouse-based click failed: {e}")
            return False

    @staticmethod
    def _bring_to_front(hwnd: int) -> None:
        """
        Bring window to front safely.

        Args:
            hwnd: Window handle
        """
        try:
            # Restore window if minimized
            if win32gui.IsIconic(hwnd):
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)

            time.sleep(0.05)

            # Set as foreground window
            win32gui.SetForegroundWindow(hwnd)

        except Exception:
            # Some windows resist being brought to front, which is normal
            pass


class MouseScrollHandler(IScrollHandler):
    """Scroll handler using mouse wheel events."""

    def __init__(self, config: UIConfiguration, security_config=None):
        """
        Initialize mouse scroll handler.

        Args:
            config: UI configuration
            security_config: Security configuration (optional)
        """
        if not WIN32_AVAILABLE:
            raise DependencyError("win32api modules")

        self.config = config
        self.security_config = security_config
        self.logger = get_logger(f"{__name__}.MouseScrollHandler")

    def _validate_coordinates(self, x: int, y: int) -> None:
        """
        Validate scroll coordinates for security.

        Args:
            x: X coordinate
            y: Y coordinate

        Raises:
            UICoordinateError: If coordinates are invalid
        """
        # Use security config if available, otherwise skip validation
        if (self.security_config and
            hasattr(self.security_config, 'validate_coordinates') and
            self.security_config.validate_coordinates):

            if not (self.security_config.min_coordinate_value <= x <= self.security_config.max_coordinate_value):
                raise UICoordinateError(
                    f"X coordinate out of bounds: {x}",
                    x=x, y=y
                )
            if not (self.security_config.min_coordinate_value <= y <= self.security_config.max_coordinate_value):
                raise UICoordinateError(
                    f"Y coordinate out of bounds: {y}",
                    x=x, y=y
                )

    @log_performance()
    def scroll(self, hwnd: int, x: int, y: int, up: int, down: int) -> bool:
        """
        Perform scrolling operations.

        Args:
            hwnd: Window handle
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)
            up: Number of scroll-up operations
            down: Number of scroll-down operations

        Returns:
            True if scroll was successful, False otherwise

        Raises:
            UICoordinateError: If coordinates are invalid
            WindowError: If scroll operation fails
        """
        self._validate_coordinates(x, y)

        if up <= 0 and down <= 0:
            raise WindowError("No scroll operations specified (up and down both zero)")

        self.logger.debug(f"Scrolling at ({x}, {y}): up={up}, down={down}")

        try:
            # Bring window to front
            self._bring_to_front(hwnd)

            # Convert client coordinates to screen coordinates
            sx, sy = win32gui.ClientToScreen(hwnd, (x, y))

            # Set cursor position
            win32api.SetCursorPos((sx, sy))
            time.sleep(self.config.scroll_delay)

            # Perform scroll-up operations
            for i in range(up):
                win32api.mouse_event(
                    win32con.MOUSEEVENTF_WHEEL,
                    0, 0,
                    self.config.scroll_wheel_amount,
                    0
                )
                time.sleep(self.config.scroll_delay)

            # Perform scroll-down operations
            for i in range(down):
                win32api.mouse_event(
                    win32con.MOUSEEVENTF_WHEEL,
                    0, 0,
                    -self.config.scroll_wheel_amount,
                    0
                )
                time.sleep(self.config.scroll_delay)

            self.logger.debug(f"Scrolling completed: up={up}, down={down}")
            return True

        except Exception as e:
            raise WindowError(f"Scroll operation failed: {e}")

    @staticmethod
    def _bring_to_front(hwnd: int) -> None:
        """
        Bring window to front safely.

        Args:
            hwnd: Window handle
        """
        try:
            # Restore window if minimized
            if win32gui.IsIconic(hwnd):
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)

            time.sleep(0.05)

            # Set as foreground window
            win32gui.SetForegroundWindow(hwnd)

        except Exception:
            # Some windows resist being brought to front, which is normal
            pass


# ============ CONTROLLER ============

class WindowController:
    """
    Main window controller with SOLID design principles.

    Provides a clean interface for window automation operations with
    proper error handling, logging, and security validation.
    """

    def __init__(
        self,
        finder: IWindowFinder,
        clicker: IClickHandler,
        scroller: IScrollHandler,
        pattern: str,
        config: UIConfiguration
    ):
        """
        Initialize window controller.

        Args:
            finder: Window finder implementation
            clicker: Click handler implementation
            scroller: Scroll handler implementation
            pattern: Window title pattern
            config: UI configuration
        """
        self.finder = finder
        self.clicker = clicker
        self.scroller = scroller
        self.pattern = pattern
        self.config = config
        self.hwnd: Optional[int] = None
        self.logger = get_logger(f"{__name__}.WindowController")

        self.logger.info(f"WindowController initialized with pattern: {pattern}")

    @log_performance()
    def attach(self, index: int = 0, timeout: Optional[float] = None) -> int:
        """
        Find and attach to a window matching the pattern.

        Args:
            index: Index of matching window to select (0 = first match)
            timeout: Timeout in seconds (uses config default if None)

        Returns:
            Window handle

        Raises:
            WindowNotFoundError: If no matching window is found
            TimeoutError: If operation times out
            WindowError: If attachment fails
        """
        timeout = timeout or self.config.operation_timeout
        start_time = time.time()

        self.logger.info(f"Searching for window pattern: {self.pattern} (index: {index})")

        while time.time() - start_time < timeout:
            try:
                matches = self.finder.find(self.pattern)

                if not matches:
                    self.logger.debug(f"No windows found, retrying...")
                    time.sleep(0.5)
                    continue

                if index >= len(matches):
                    raise WindowError(
                        f"Index {index} out of range (found {len(matches)} windows)"
                    )

                self.hwnd = matches[index]
                self.logger.info(f"Attached to window {hex(self.hwnd)} (index: {index})")
                return self.hwnd

            except Exception as e:
                if isinstance(e, (WindowNotFoundError, WindowError)):
                    raise
                self.logger.warning(f"Error during attach attempt: {e}")
                time.sleep(0.5)

        raise TimeoutError("Window attachment", timeout)

    def click(self, x: int, y: int) -> bool:
        """
        Perform click at specified coordinates.

        Args:
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)

        Returns:
            True if click was successful

        Raises:
            WindowError: If not attached or click fails
        """
        if not self.hwnd:
            raise WindowError("Not attached to any window - call attach() first")

        operation_id = self.logger.log_operation_start(
            "click",
            hwnd=hex(self.hwnd),
            x=x, y=y
        )

        try:
            result = self.clicker.click(self.hwnd, x, y)
            self.logger.log_operation_end(operation_id, success=result)
            return result

        except Exception as e:
            self.logger.log_operation_end(operation_id, success=False)
            raise

    def scroll(self, x: int, y: int, *, up: int = 0, down: int = 0) -> bool:
        """
        Perform scroll at specified coordinates.

        Args:
            x: X coordinate (client-relative)
            y: Y coordinate (client-relative)
            up: Number of scroll-up operations
            down: Number of scroll-down operations

        Returns:
            True if scroll was successful

        Raises:
            WindowError: If not attached or scroll fails
        """
        if not self.hwnd:
            raise WindowError("Not attached to any window - call attach() first")

        operation_id = self.logger.log_operation_start(
            "scroll",
            hwnd=hex(self.hwnd),
            x=x, y=y,
            up=up, down=down
        )

        try:
            result = self.scroller.scroll(self.hwnd, x, y, up, down)
            self.logger.log_operation_end(operation_id, success=result)
            return result

        except Exception as e:
            self.logger.log_operation_end(operation_id, success=False)
            raise

    def get_info(self) -> WindowInfo:
        """
        Get information about the attached window.

        Returns:
            WindowInfo object with window details

        Raises:
            WindowError: If not attached to any window
        """
        if not self.hwnd:
            raise WindowError("Not attached to any window - call attach() first")

        try:
            title = win32gui.GetWindowText(self.hwnd)
            window_rect = win32gui.GetWindowRect(self.hwnd)
            client_rect = win32gui.GetClientRect(self.hwnd)
            is_visible = win32gui.IsWindowVisible(self.hwnd)
            is_minimized = win32gui.IsIconic(self.hwnd)

            return WindowInfo(
                hwnd=self.hwnd,
                title=title,
                window_rect=window_rect,
                client_rect=client_rect,
                is_visible=is_visible,
                is_minimized=is_minimized
            )

        except Exception as e:
            raise WindowError(f"Failed to get window info: {e}")

    def is_attached(self) -> bool:
        """Check if controller is attached to a window."""
        if not self.hwnd:
            return False

        try:
            # Check if window still exists and is valid
            return win32gui.IsWindow(self.hwnd)
        except:
            return False

    def detach(self) -> None:
        """Detach from the current window."""
        if self.hwnd:
            self.logger.info(f"Detaching from window {hex(self.hwnd)}")
            self.hwnd = None

    @staticmethod
    def create(pattern: str, config: Optional[UIConfiguration] = None, security_config=None) -> 'WindowController':
        """
        Factory method to create WindowController with default implementations.

        Args:
            pattern: Window title pattern
            config: UI configuration (uses default if None)
            security_config: Security configuration (optional)

        Returns:
            Configured WindowController instance

        Raises:
            DependencyError: If required dependencies are missing
        """
        if not WIN32_AVAILABLE:
            raise DependencyError("win32gui modules")

        config = config or UIConfiguration()

        # Enable DPI awareness for better coordinate handling
        try:
            ctypes.windll.user32.SetProcessDPIAware()
        except Exception:
            pass

        return WindowController(
            finder=RegexWindowFinder(config),
            clicker=HybridClickHandler(config, security_config),
            scroller=MouseScrollHandler(config, security_config),
            pattern=pattern,
            config=config
        )